Require Import String List.

Set Implicit Arguments.


(** Mode of a message-passing channel *)
Inductive direction := Send | Recv.

(** Description of available channels *)
Definition channel := string.
Definition channels := channel -> Type.

(** Message-passing processes *)
Section process.
  Variable chs : channels.

  CoInductive process :=
  | DoSend (ch : channel) (v : chs ch) (k : process)
  | DoRecv (ch : channel) (k : chs ch -> process)
  | Parallel (pr1 pr2 : process)
  | Restrict (which : direction * channel -> Prop) (k : process)
  | Done.

  Definition trace := list (direction * sigT chs).

  (** Interleave two traces, possibly doing matchmaking of sends and recvs. *)
  Inductive interleave : trace -> trace -> trace -> Prop :=
  | IntNil1 : forall tr, interleave nil tr tr
  | IntNil2 : forall tr, interleave tr nil tr
  | IntCons1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (v :: tr1) tr2 (v :: tr)
  | IntCons2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave tr1 (v :: tr2) (v :: tr)
  | IntMatch1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave ((Send, v) :: tr1) ((Recv, v) :: tr2) tr
  | IntMatch2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave ((Recv, v) :: tr1) ((Send, v) :: tr2) tr.

  (** Ensure that a predicate holds for all trace elements. *)
  Definition traceAll (which : direction * channel -> Prop) : trace -> Prop :=
    List.Forall (fun v => which (fst v, projT1 (snd v))).

  (** Traces generated by a process *)
  Inductive traceOf : process -> trace -> Prop :=
  | TrSend : forall ch v k tr,
    traceOf k tr
    -> traceOf (@DoSend ch v k) ((Send, existT _ ch v) :: tr)
  | TrRecv : forall ch v k tr,
    traceOf (k v) tr
    -> traceOf (@DoRecv ch k) ((Recv, existT _ ch v) :: tr)
  | TrParallel : forall pr1 tr1 pr2 tr2 tr,
    traceOf pr1 tr1
    -> traceOf pr2 tr2
    -> interleave tr1 tr2 tr
    -> traceOf (Parallel pr1 pr2) tr
  | TrRestrict : forall which pr tr,
    traceOf pr tr
    -> traceAll which tr
    -> traceOf (Restrict which pr) tr
  | TrDone : forall pr, traceOf pr nil. (* Scheduler might always give up on a process. *)

  (** Consider all traces of two processes. *)
  Definition refines (pr1 pr2 : process) :=
    forall tr, traceOf pr1 tr
      -> traceOf pr2 tr.

  Definition expand (pr : process) : process :=
    match pr with
      | DoSend ch v k => DoSend (ch := ch) v k
      | DoRecv ch k => DoRecv (ch := ch) k
      | Parallel pr1 pr2 => Parallel pr1 pr2
      | Restrict which k => Restrict which k
      | Done => Done
    end.

  Theorem expand_ok : forall pr, pr = expand pr.
  Proof.
    destruct pr; auto.
  Qed.
End process.


Implicit Arguments Done [chs].

Notation "#! chs [ ch , v ] , k" := (DoSend (chs := chs) ch v k) (at level 100, chs at level 0).
Notation "#? chs [ ch , x ] , k" := (DoRecv (chs := chs) ch (fun x => k)) (at level 100, chs at level 0).
Notation "## [ x1 , .. , xN ] , k" := (Restrict (fun p => In p (cons x1 (.. (cons xN nil) ..))) k) (at level 100).
Infix "||" := Parallel.
Export String.
Global Open Scope string_scope.

Hint Constructors interleave traceOf.
Hint Unfold traceAll.
