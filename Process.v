Require Import String.

Set Implicit Arguments.


Section stream.
  Variable A : Type.

  CoInductive stream :=
  | SNil
  | SCons (a : A) (s : stream).
End stream.

Implicit Arguments SNil [A].


(** Mode of a message-passing channel *)
Inductive direction := Send | Recv.

(** Description of available channels *)
Definition channels := string -> Type.

(** Message-passing processes *)
Section process.
  Variable chs : channels.

  CoInductive process :=
  | DoSend (ch : string) (v : chs ch) (k : process)
  | DoRecv (ch : string) (k : chs ch -> process)
  | Internal (k : process)
  | Parallel (pr1 pr2 : process)
  | Done.

  Definition trace := stream (direction * sigT chs).

  (** Interleave two traces, possibly doing matchmaking of sends and recvs. *)
  CoInductive interleave : trace -> trace -> trace -> Prop :=
  | IntNil1 : forall tr, interleave SNil tr tr
  | IntNil2 : forall tr, interleave tr SNil tr
  | IntCons1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons v tr1) tr2 (SCons v tr)
  | IntCons2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave tr1 (SCons v tr2) (SCons v tr)
  | IntMatch1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Send, v) tr1) (SCons (Recv, v) tr2) tr
  | IntMatch2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Recv, v) tr1) (SCons (Send, v) tr2) tr.

  (** Traces generated by a process *)
  CoInductive traceOf : process -> trace -> Prop :=
  | TrSend : forall ch v k tr,
    traceOf k tr
    -> traceOf (@DoSend ch v k) (SCons (Send, existT _ ch v) tr)
  | TrRecv : forall ch v k tr,
    traceOf (k v) tr
    -> traceOf (@DoRecv ch k) (SCons (Recv, existT _ ch v) tr)
  | TrInternal : forall k tr,
    traceOf k tr
    -> traceOf (Internal k) tr
  | TrParallel : forall pr1 tr1 pr2 tr2 tr,
    traceOf pr1 tr1
    -> traceOf pr2 tr2
    -> interleave tr1 tr2 tr
    -> traceOf (Parallel pr1 pr2) tr
  | TrDone : forall pr, traceOf pr SNil. (* Scheduler might always give up on a process. *)

  Section traces.
    Variable which : string -> Prop.
    (** Which subset of channels are we paying attention to? *)

    (** A trace never mentions any of the channels we care about. *)
    CoInductive noneRelevant : trace -> Prop :=
    | NrNil : noneRelevant SNil
    | NrCons : forall v tr,
      ~which (projT1 (snd v))
      -> noneRelevant (SCons v tr).

    (** Find the first matching event in a trace. *)
    Inductive firstRelevant : trace -> direction * sigT chs -> trace -> Prop :=
    | FrFound : forall v tr,
      which (projT1 (snd v))
      -> firstRelevant (SCons v tr) v tr
    | FrMore : forall v tr v' tr',
      ~which (projT1 (snd v))
      -> firstRelevant tr v' tr'
      -> firstRelevant (SCons v tr) v' tr'.

    (** Compare two traces, considering only a restricted set of channels. *)
    CoInductive traceRefines : trace -> trace -> Prop :=
    | TrNone : forall tr1 tr2,
      noneRelevant tr1
      -> noneRelevant tr2
      -> traceRefines tr1 tr2
    | TrSome : forall tr1 tr2 v tr1' tr2',
      firstRelevant tr1 v tr1'
      -> firstRelevant tr2 v tr2'
      -> traceRefines tr1' tr2'
      -> traceRefines tr1 tr2.

    (** Consider all traces of two processes. *)
    Definition refines (pr1 pr2 : process) :=
      forall tr1, traceOf pr1 tr1
        -> exists tr2, traceOf pr2 tr2
          /\ traceRefines tr1 tr2.
  End traces.
End process.


Implicit Arguments Done [chs].

Notation "#! chs [ ch , v ] , k" := (DoSend (chs := chs) ch v k) (at level 100, chs at level 0).
Notation "#? chs [ ch , x ] , k" := (DoRecv (chs := chs) ch (fun x => k)) (at level 100, chs at level 0).
Notation "#_ , k" := (Internal k) (at level 100).
Infix "||" := Parallel.
Export String.
Global Open Scope string_scope.

Hint Constructors interleave traceOf noneRelevant firstRelevant traceRefines.
