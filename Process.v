Require Import List String.

Set Implicit Arguments.


Section stream.
  Variable A : Type.

  CoInductive stream :=
  | SNil
  | SCons (a : A) (s : stream).
End stream.

Implicit Arguments SNil [A].


(** Mode of a message-passing channel *)
Inductive direction := Send | Recv.

(** Description of available channels *)
Definition channel := string.
Definition channels := channel -> Type.

(** Message-passing processes *)
Section process.
  Variable chs : channels.

  CoInductive process :=
  | DoSend (ch : channel) (v : chs ch) (k : process)
  | DoRecv (ch : channel) (k : chs ch -> process)
  | Internal (k : process)
  | Parallel (pr1 pr2 : process)
  | Restrict (which : direction * channel -> Prop) (k : process)
  | Done.

  Definition trace := stream (direction * sigT chs).

  (** Interleave two traces, possibly doing matchmaking of sends and recvs. *)
  CoInductive interleave : trace -> trace -> trace -> Prop :=
  | IntNil1 : forall tr, interleave SNil tr tr
  | IntNil2 : forall tr, interleave tr SNil tr
  | IntCons1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons v tr1) tr2 (SCons v tr)
  | IntCons2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave tr1 (SCons v tr2) (SCons v tr)
  | IntMatch1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Send, v) tr1) (SCons (Recv, v) tr2) tr
  | IntMatch2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Recv, v) tr1) (SCons (Send, v) tr2) tr.

  (** Ensure that a predicate holds for all trace elements. *)
  CoInductive traceAll (which : direction * channel -> Prop) : trace -> Prop :=
  | AlNil : traceAll which SNil
  | AlCons : forall v tr, which (fst v, projT1 (snd v))
    -> traceAll which tr
    -> traceAll which (SCons v tr).

  (** Traces generated by a process *)
  CoInductive traceOf : process -> trace -> Prop :=
  | TrSend : forall ch v k tr,
    traceOf k tr
    -> traceOf (@DoSend ch v k) (SCons (Send, existT _ ch v) tr)
  | TrRecv : forall ch v k tr,
    traceOf (k v) tr
    -> traceOf (@DoRecv ch k) (SCons (Recv, existT _ ch v) tr)
  | TrInternal : forall k tr,
    traceOf k tr
    -> traceOf (Internal k) tr
  | TrParallel : forall pr1 tr1 pr2 tr2 tr,
    traceOf pr1 tr1
    -> traceOf pr2 tr2
    -> interleave tr1 tr2 tr
    -> traceOf (Parallel pr1 pr2) tr
  | TrRestrict : forall which pr tr,
    traceOf pr tr
    -> traceAll which tr
    -> traceOf (Restrict which pr) tr
  | TrDone : forall pr, traceOf pr SNil. (* Scheduler might always give up on a process. *)

  CoInductive traceEqual : trace -> trace -> Prop :=
  | TrNil : traceEqual SNil SNil
  | TrCons : forall v tr1 tr2, traceEqual tr1 tr2
    -> traceEqual (SCons v tr1) (SCons v tr2).

  Theorem traceEqual_refl : forall tr, traceEqual tr tr.
  Proof.
    cofix; destruct tr; constructor; auto.
  Qed.

  (** Consider all traces of two processes. *)
  Definition refines (pr1 pr2 : process) :=
    forall tr1, traceOf pr1 tr1
      -> exists tr2, traceOf pr2 tr2
        /\ traceEqual tr1 tr2.

  Definition expand (pr : process) : process :=
    match pr with
      | DoSend ch v k => DoSend (ch := ch) v k
      | DoRecv ch k => DoRecv (ch := ch) k
      | Internal k => Internal k
      | Parallel pr1 pr2 => Parallel pr1 pr2
      | Restrict which k => Restrict which k
      | Done => Done
    end.

  Theorem expand_ok : forall pr, pr = expand pr.
  Proof.
    destruct pr; auto.
  Qed.
End process.


Implicit Arguments Done [chs].

Notation "#! chs [ ch , v ] , k" := (DoSend (chs := chs) ch v k) (at level 100, chs at level 0).
Notation "#? chs [ ch , x ] , k" := (DoRecv (chs := chs) ch (fun x => k)) (at level 100, chs at level 0).
Notation "#_ , k" := (Internal k) (at level 100).
Notation "## [ x1 , .. , xN ] , k" := (Restrict (fun p => In p (cons x1 (.. (cons xN nil) ..))) k) (at level 100).
Infix "||" := Parallel.
Export String.
Global Open Scope string_scope.

Hint Constructors interleave traceAll traceOf traceEqual.
Hint Resolve traceEqual_refl.
