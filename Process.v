Require Import String.

Set Implicit Arguments.


Section stream.
  Variable A : Type.

  CoInductive stream :=
  | SNil
  | SCons (a : A) (s : stream).
End stream.

Implicit Arguments SNil [A].


(** Mode of a message-passing channel *)
Inductive direction := Send | Recv.

(** Description of available channels *)
Definition channels := string -> Type.

(** Message-passing processes *)
Section process.
  Variable chs : channels.

  CoInductive process :=
  | DoSend (ch : string) (v : chs ch) (k : process)
  | DoRecv (ch : string) (k : chs ch -> process)
  | Internal (k : process)
  | Parallel (pr1 pr2 : process)
  | Done.

  Definition trace := stream (direction * sigT chs).

  (** Interleave two traces, possibly doing matchmaking of sends and recvs. *)
  CoInductive interleave : trace -> trace -> trace -> Prop :=
  | IntNil1 : forall tr, interleave SNil tr tr
  | IntNil2 : forall tr, interleave tr SNil tr
  | IntCons1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons v tr1) tr2 (SCons v tr)
  | IntCons2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave tr1 (SCons v tr2) (SCons v tr)
  | IntMatch1 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Send, v) tr1) (SCons (Recv, v) tr2) tr
  | IntMatch2 : forall v tr1 tr2 tr,
    interleave tr1 tr2 tr
    -> interleave (SCons (Recv, v) tr1) (SCons (Send, v) tr2) tr.

  (** Traces generated by a process *)
  CoInductive traceOf : process -> trace -> Prop :=
  | TrSend : forall ch v k tr,
    traceOf k tr
    -> traceOf (@DoSend ch v k) (SCons (Send, existT _ ch v) tr)
  | TrRecv : forall ch v k tr,
    traceOf (k v) tr
    -> traceOf (@DoRecv ch k) (SCons (Recv, existT _ ch v) tr)
  | TrInternal : forall k tr,
    traceOf k tr
    -> traceOf (Internal k) tr
  | TrParallel : forall pr1 tr1 pr2 tr2 tr,
    traceOf pr1 tr1
    -> traceOf pr2 tr2
    -> interleave tr1 tr2 tr
    -> traceOf (Parallel pr1 pr2) tr
  | TrDone : forall pr, traceOf pr SNil. (* Scheduler might always give up on a process. *)

  CoInductive traceEqual : trace -> trace -> Prop :=
  | TrNil : traceEqual SNil SNil
  | TrCons : forall v tr1 tr2, traceEqual tr1 tr2
    -> traceEqual (SCons v tr1) (SCons v tr2).

  Theorem traceEqual_refl : forall tr, traceEqual tr tr.
  Proof.
    cofix; destruct tr; constructor; auto.
  Qed.

  (** Consider all traces of two processes. *)
  Definition refines (pr1 pr2 : process) :=
    forall tr1, traceOf pr1 tr1
      -> exists tr2, traceOf pr2 tr2
        /\ traceEqual tr1 tr2.
End process.


Implicit Arguments Done [chs].

Notation "#! chs [ ch , v ] , k" := (DoSend (chs := chs) ch v k) (at level 100, chs at level 0).
Notation "#? chs [ ch , x ] , k" := (DoRecv (chs := chs) ch (fun x => k)) (at level 100, chs at level 0).
Notation "#_ , k" := (Internal k) (at level 100).
Infix "||" := Parallel.
Export String.
Global Open Scope string_scope.

Hint Constructors interleave traceOf traceEqual.
Hint Resolve traceEqual_refl.
